/**
 * Generate TypeScript common types from common.schema.json
 *
 * This generator creates TypeScript type definitions for common/shared types
 * used across the Salvage Union data schemas.
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'
import {
  loadSchema,
  analyzeSchemaDependencies,
  topologicalSort,
  type JSONSchema,
} from './schemaAnalysis.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const OUTPUT_FILE = path.join(__dirname, '../lib/types/common.ts')

/**
 * Capitalize first letter of a string
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

/**
 * Convert snake_case to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split('_')
    .map((part) => capitalize(part))
    .join('')
}

/**
 * Generate TypeScript type definition from common schema definition
 */
function generateCommonType(name: string, schema: JSONSchema): string | null {
  const typeName = `SURefCommon${toPascalCase(name)}`
  const lines: string[] = []

  if (schema.description) {
    lines.push('/**')
    lines.push(` * ${schema.description}`)
    lines.push(' */')
  }

  // Handle oneOf (union types)
  if (schema.oneOf) {
    const types: string[] = []
    for (const option of schema.oneOf) {
      if (option.type === 'integer' || option.type === 'number') {
        types.push('number')
      } else if (option.type === 'string') {
        if (option.const) {
          types.push(`'${option.const}'`)
        } else {
          types.push('string')
        }
      }
    }

    if (types.length > 0) {
      lines.push(`export type ${typeName} = ${types.join(' | ')}`)
      return lines.join('\n')
    }
  }

  // Handle simple types
  if (schema.type === 'integer' || schema.type === 'number') {
    lines.push(`export type ${typeName} = number`)
    return lines.join('\n')
  }

  if (schema.type === 'string') {
    lines.push(`export type ${typeName} = string`)
    return lines.join('\n')
  }

  // Handle $ref - these are aliases to other common types
  if (schema.$ref) {
    const refName = schema.$ref.split('/').pop()
    if (refName) {
      const refTypeName = `SURefCommon${toPascalCase(refName)}`
      lines.push(`export type ${typeName} = ${refTypeName}`)
      return lines.join('\n')
    }
  }

  // Skip types we can't handle
  console.warn(`âš ï¸  Skipping ${name}: unsupported schema structure`)
  return null
}

async function generateCommonTypes() {
  console.log('ğŸ”§ Generating TypeScript common types from common.schema.json...\n')

  // Read the common schema
  const commonSchema = loadSchema('schemas/shared/common.schema.json')

  const typeDefinitions: string[] = []

  // Header
  typeDefinitions.push('/**')
  typeDefinitions.push(' * Auto-generated TypeScript common types from common.schema.json')
  typeDefinitions.push(' * DO NOT EDIT MANUALLY')
  typeDefinitions.push(' * Generated by tools/generateCommonTypes.ts')
  typeDefinitions.push(' */')
  typeDefinitions.push('')

  // Generate types in dependency order using schema analysis
  const definitions = commonSchema.definitions || commonSchema.$defs || {}
  const dependencyGraph = analyzeSchemaDependencies(commonSchema, definitions)
  const sortedTypes = topologicalSort(dependencyGraph)

  console.log('ğŸ“‹ Generating types in dependency order...')
  for (const typeName of sortedTypes) {
    if (definitions[typeName]) {
      const typeCode = generateCommonType(typeName, definitions[typeName])
      if (typeCode) {
        typeDefinitions.push(typeCode)
        typeDefinitions.push('')
        console.log(`   âœ“ ${typeName}`)
      }
    }
  }

  // Write output file
  const output = typeDefinitions.join('\n')
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8')

  console.log('\nâœ… Common types generated successfully!')
  console.log(`ğŸ“„ Output: ${OUTPUT_FILE}`)
  console.log(`ğŸ“Š Generated ${sortedTypes.length} common types`)
}

// Run the generator
generateCommonTypes().catch((error) => {
  console.error('âŒ Common type generation failed:', error)
  process.exit(1)
})
