/**
 * Generate lib/types/index.ts with union types and imports
 * Auto-generates from schema index
 */

import * as fs from 'fs'
import * as path from 'path'
import { getDirname, loadSchemaIndex, getSingularTypeName } from './generatorUtils.js'
import { getTypeAliases } from './schemaAnalysis.js'

const __dirname = getDirname(import.meta.url)
const OUTPUT_FILE = path.join(__dirname, '../lib/types/index.ts')

function generateTypeIndex() {
  console.log('ðŸ”§ Generating lib/types/index.ts...\n')

  const schemaIndex = loadSchemaIndex(__dirname)
  const typeAliases = getTypeAliases(schemaIndex)

  const lines: string[] = []

  // Header
  lines.push('/**')
  lines.push(' * Auto-generated TypeScript type exports')
  lines.push(' * DO NOT EDIT MANUALLY')
  lines.push(' * Generated by tools/generateTypeIndex.ts')
  lines.push(' */')
  lines.push('')

  // Collect all schema types for imports (excluding type aliases which are defined elsewhere)
  const schemaTypeImports: string[] = []
  const entityTypes: string[] = []
  const metaEntityTypes: string[] = []

  for (const schema of schemaIndex.schemas) {
    // Skip schemas with type aliases - they're defined in objects.ts, not schemas.ts
    if (typeAliases.has(schema.id)) {
      // But still add them to meta entity types if they're not non-entity
      if (!schema.nonEntity) {
        const aliasType = typeAliases.get(schema.id)!
        metaEntityTypes.push(aliasType)
      }
      continue
    }

    // Skip non-entity schemas from imports (they're not exported from schemas.ts)
    if (schema.nonEntity) {
      continue
    }

    const singularName = getSingularTypeName(schema.id, __dirname)
    const prefix = schema.meta ? 'SURefMeta' : 'SURef'
    const typeName = `${prefix}${singularName}`

    schemaTypeImports.push(typeName)

    // Entity types (non-meta, non-nonEntity)
    if (!schema.meta && !schema.nonEntity) {
      entityTypes.push(typeName)
    }

    // Meta entity types (all schemas except non-entities)
    if (!schema.nonEntity) {
      metaEntityTypes.push(typeName)
    }
  }

  // Import types for use in union types
  if (schemaTypeImports.length > 0) {
    lines.push('// Import types for use in union types')
    lines.push('import type {')
    schemaTypeImports.sort().forEach((type) => {
      lines.push(`  ${type},`)
    })
    lines.push("} from './schemas.js'")
    lines.push('')
  }

  // Export all enum types
  lines.push('// Export all enum types')
  lines.push("export type * from './enums.js'")
  lines.push('')

  // Export all common types
  lines.push('// Export all common types')
  lines.push("export type * from './common.js'")
  lines.push('')

  // Export all object types
  lines.push('// Export all object types')
  lines.push("export type * from './objects.js'")
  lines.push('')

  // Export all schema types
  lines.push('// Export all schema types')
  lines.push("export type * from './schemas.js'")
  lines.push('')

  // Re-export specific commonly used types for convenience
  lines.push('// Re-export specific commonly used types for convenience')
  lines.push('export type {')
  lines.push('  SURefSchemaName,')
  lines.push('  SURefTree,')
  lines.push('  SURefActionType,')
  lines.push('  SURefDamageType,')
  lines.push('  SURefRange,')
  lines.push('  SURefSource,')
  lines.push('  SURefClassType,')
  lines.push('  SURefContentType,')
  lines.push("} from './enums.js'")
  lines.push('')

  lines.push('export type {')
  lines.push('  SURefId,')
  lines.push('  SURefName,')
  lines.push('  SURefTechLevel,')
  lines.push('  SURefSalvageValue,')
  lines.push('  SURefHitPoints,')
  lines.push('  SURefStructurePoints,')
  lines.push('  SURefPositiveInteger,')
  lines.push('  SURefNonNegativeInteger,')
  lines.push('  SURefActivationCost,')
  lines.push('  SURefAssetUrl,')
  lines.push("} from './common.js'")
  lines.push('')

  lines.push('export type {')
  lines.push('  SURefMetaTrait,')
  lines.push('  SURefMetaStats,')
  lines.push('  SURefMetaChassisStats,')
  lines.push('  SURefMetaEquipmentStats,')
  lines.push('  SURefMetaDataValue,')
  lines.push('  SURefMetaChoice,')
  lines.push('  SURefMetaNpc,')
  lines.push('  SURefMetaSystemModule,')
  lines.push('  SURefMetaTable,')
  lines.push('  SURefMetaAdvancedClass,')
  lines.push('  SURefMetaAction,')
  lines.push('  SURefMetaGrant,')
  lines.push('  SURefMetaChoices,')
  lines.push('  SURefMetaContent,')
  lines.push('  SURefMetaContentBlock,')
  lines.push('  SURefMetaPattern,')
  lines.push('  SURefMetaSystems,')
  lines.push('  SURefMetaModules,')
  lines.push('  SURefMetaTraits,')
  lines.push('  SURefMetaBaseEntity,')
  lines.push('  SURefMetaCombatEntity,')
  lines.push('  SURefMetaMechanicalEntity,')
  lines.push('  SURefMetaSchemaName,')
  lines.push("} from './objects.js'")
  lines.push('')

  // Union type of all entity types (excludes meta schemas and non-entities)
  lines.push('// Union type of all entity types (excludes meta schemas and non-entities)')
  lines.push('export type SURefEntity =')
  entityTypes.sort().forEach((type, index) => {
    const prefix = index === 0 ? '  ' : '  | '
    lines.push(`${prefix}${type}`)
  })
  lines.push('')

  // Union type of all meta entity types (includes all schemas except non-entities)
  lines.push('// Union type of all meta entity types (includes all schemas except non-entities)')
  lines.push('export type SURefMetaEntity =')
  metaEntityTypes.sort().forEach((type, index) => {
    const prefix = index === 0 ? '  ' : '  | '
    lines.push(`${prefix}${type}`)
  })

  // Write output file
  const output = lines.join('\n')
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8')

  console.log('âœ… Generated lib/types/index.ts')
  console.log(`   - ${entityTypes.length} entity types`)
  console.log(`   - ${metaEntityTypes.length} meta entity types`)
}

generateTypeIndex()
