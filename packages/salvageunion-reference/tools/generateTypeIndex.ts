/**
 * Generate lib/types/index.ts with union types and imports
 * Auto-generates from schema index
 */

import * as fs from 'fs'
import * as path from 'path'
import { getDirname, loadSchemaIndex, getSingularTypeName } from './generatorUtils.js'
import { getTypeAliases } from './schemaAnalysis.js'

const __dirname = getDirname(import.meta.url)
const OUTPUT_FILE = path.join(__dirname, '../lib/types/index.ts')

function generateTypeIndex() {
  console.log('ðŸ”§ Generating lib/types/index.ts...\n')

  const schemaIndex = loadSchemaIndex(__dirname)
  const typeAliases = getTypeAliases(schemaIndex)

  const lines: string[] = []

  // Header
  lines.push('/**')
  lines.push(' * Auto-generated TypeScript type exports')
  lines.push(' * DO NOT EDIT MANUALLY')
  lines.push(' * Generated by tools/generateTypeIndex.ts')
  lines.push(' */')
  lines.push('')

  // Collect all schema types for imports (excluding type aliases which are defined elsewhere)
  const schemaTypeImports: string[] = []
  const entityTypes: string[] = []
  const metaEntityTypes: string[] = []

  for (const schema of schemaIndex.schemas) {
    // Skip schemas with type aliases - they're defined in objects.ts, not schemas.ts
    if (typeAliases.has(schema.id)) {
      // But still add them to meta entity types if they're not non-entity
      if (!schema.nonEntity) {
        const aliasType = typeAliases.get(schema.id)!
        metaEntityTypes.push(aliasType)
      }
      continue
    }

    // Skip non-entity schemas from imports (they're not exported from schemas.ts)
    // meta and nonEntity are 1:1 - if meta is true, treat as nonEntity
    const isNonEntity = schema.nonEntity === true || schema.meta === true
    if (isNonEntity) {
      // For meta schemas, we still need to add them to metaEntityTypes and import from schemas.ts
      if (schema.meta === true && !typeAliases.has(schema.id)) {
        const singularName = getSingularTypeName(schema.id, __dirname)
        const typeName = `SURefMeta${singularName}`
        metaEntityTypes.push(typeName)
        // These are defined in schemas.ts, so add to imports
        schemaTypeImports.push(typeName)
      }
      continue
    }

    const singularName = getSingularTypeName(schema.id, __dirname)
    const prefix = schema.meta ? 'SURefMeta' : 'SURef'
    const typeName = `${prefix}${singularName}`

    schemaTypeImports.push(typeName)

    // Entity types (non-meta, non-nonEntity)
    // meta and nonEntity are 1:1 - if meta is true, treat as nonEntity
    // isNonEntity was already computed above
    if (!isNonEntity) {
      entityTypes.push(typeName)
    }

    // Meta entity types (all schemas except non-entities)
    // meta and nonEntity are 1:1 - if meta is true, treat as nonEntity
    // isNonEntity was already computed above
    if (!isNonEntity) {
      metaEntityTypes.push(typeName)
    } else if (schema.meta === true) {
      // Meta schemas are still meta entities (they're in SURefMetaEntity union)
      metaEntityTypes.push(typeName)
    }
  }

  // Import types for use in union types
  if (schemaTypeImports.length > 0) {
    lines.push('// Import types for use in union types')
    lines.push('import type {')
    schemaTypeImports.sort().forEach((type) => {
      lines.push(`  ${type},`)
    })
    lines.push("} from './schemas.js'")
    lines.push('')
  }

  // Export all enum types
  lines.push('// Export all enum types')
  lines.push("export type * from './enums.js'")
  lines.push('')

  // Export all common types
  lines.push('// Export all common types')
  lines.push("export type * from './common.js'")
  lines.push('')

  // Export all object types
  lines.push('// Export all object types')
  lines.push("export type * from './objects.js'")
  lines.push('')

  // Export all schema types
  lines.push('// Export all schema types')
  lines.push("export type * from './schemas.js'")
  lines.push('')

  // Re-export specific commonly used types for convenience
  lines.push('// Re-export specific commonly used types for convenience')
  lines.push('export type {')
  lines.push('  SURefEnumSchemaName,')
  lines.push('  SURefEnumTree,')
  lines.push('  SURefEnumActionType,')
  lines.push('  SURefEnumDamageType,')
  lines.push('  SURefEnumRange,')
  lines.push('  SURefEnumSource,')
  lines.push('  SURefEnumClassType,')
  lines.push('  SURefEnumContentType,')
  lines.push("} from './enums.js'")
  lines.push('')

  lines.push('export type {')
  lines.push('  SURefCommonId,')
  lines.push('  SURefCommonName,')
  lines.push('  SURefCommonTechLevel,')
  lines.push('  SURefCommonSalvageValue,')
  lines.push('  SURefCommonHitPoints,')
  lines.push('  SURefCommonStructurePoints,')
  lines.push('  SURefCommonPositiveInteger,')
  lines.push('  SURefCommonNonNegativeInteger,')
  lines.push('  SURefCommonActivationCost,')
  lines.push('  SURefCommonAssetUrl,')
  lines.push("} from './common.js'")
  lines.push('')

  lines.push('export type {')
  lines.push('  SURefObjectTrait,')
  lines.push('  SURefObjectStats,')
  lines.push('  SURefObjectChassisStats,')
  lines.push('  SURefObjectEquipmentStats,')
  lines.push('  SURefObjectDataValue,')
  lines.push('  SURefObjectChoice,')
  lines.push('  SURefObjectNpc,')
  lines.push('  SURefObjectSystemModule,')
  lines.push('  SURefObjectTable,')
  lines.push('  SURefObjectAdvancedClass,')
  lines.push('  SURefObjectAction,')
  lines.push('  SURefObjectGrant,')
  lines.push('  SURefObjectChoices,')
  lines.push('  SURefObjectContent,')
  lines.push('  SURefObjectContentBlock,')
  lines.push('  SURefObjectPattern,')
  lines.push('  SURefObjectSystems,')
  lines.push('  SURefObjectModules,')
  lines.push('  SURefObjectTraits,')
  lines.push('  SURefObjectBaseEntity,')
  lines.push('  SURefObjectCombatEntity,')
  lines.push('  SURefObjectMechanicalEntity,')
  lines.push('  SURefObjectSchemaName,')
  lines.push("} from './objects.js'")
  lines.push('')

  // Union type of all entity types (excludes meta schemas and non-entities)
  lines.push('// Union type of all entity types (excludes meta schemas and non-entities)')
  lines.push('export type SURefEntity =')
  entityTypes.sort().forEach((type, index) => {
    const prefix = index === 0 ? '  ' : '  | '
    lines.push(`${prefix}${type}`)
  })
  lines.push('')

  // Union type of all meta entity types (includes all schemas except non-entities)
  lines.push('// Union type of all meta entity types (includes all schemas except non-entities)')
  lines.push('export type SURefMetaEntity =')
  metaEntityTypes.sort().forEach((type, index) => {
    const prefix = index === 0 ? '  ' : '  | '
    lines.push(`${prefix}${type}`)
  })

  // Write output file
  const output = lines.join('\n')
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8')

  console.log('âœ… Generated lib/types/index.ts')
  console.log(`   - ${entityTypes.length} entity types`)
  console.log(`   - ${metaEntityTypes.length} meta entity types`)
}

generateTypeIndex()
