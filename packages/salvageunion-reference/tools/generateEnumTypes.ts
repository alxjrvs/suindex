/**
 * Generate TypeScript enum types from enums.schema.json
 *
 * This generator creates TypeScript union types for each enum definition
 * in the shared enums schema file.
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const ENUMS_SCHEMA_PATH = path.join(__dirname, '../schemas/shared/enums.schema.json')
const OUTPUT_FILE = path.join(__dirname, '../lib/types/enums.ts')

/**
 * Capitalize first letter of a string
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

/**
 * Generate TypeScript type definition from enum schema
 */
function generateEnumType(name: string, enumValues: string[], description?: string): string {
  const typeName = `SURef${capitalize(name)}`
  const lines: string[] = []

  if (description) {
    lines.push('/**')
    lines.push(` * ${description}`)
    lines.push(' */')
  }

  lines.push(`export type ${typeName} =`)
  enumValues.forEach((value, index) => {
    const isLast = index === enumValues.length - 1
    lines.push(`  | '${value}'${isLast ? '' : ''}`)
  })

  return lines.join('\n')
}

async function generateEnumTypes() {
  console.log('ğŸ”§ Generating TypeScript enum types from enums.schema.json...\n')

  // Read the enums schema
  const enumsSchema = JSON.parse(fs.readFileSync(ENUMS_SCHEMA_PATH, 'utf8'))

  const typeDefinitions: string[] = []

  // Header
  typeDefinitions.push('/**')
  typeDefinitions.push(' * Auto-generated TypeScript enum types from enums.schema.json')
  typeDefinitions.push(' * DO NOT EDIT MANUALLY')
  typeDefinitions.push(' * Generated by tools/generateEnumTypes.ts')
  typeDefinitions.push(' */')
  typeDefinitions.push('')

  // Generate a type for each enum definition
  const definitions = enumsSchema.definitions || {}
  const enumNames = Object.keys(definitions).sort()

  console.log(`ğŸ“‹ Found ${enumNames.length} enum definitions:`)
  enumNames.forEach((name) => console.log(`   - ${name}`))
  console.log('')

  for (const enumName of enumNames) {
    const enumDef = definitions[enumName]

    if (enumDef.type === 'string' && Array.isArray(enumDef.enum)) {
      // Simple string enum
      const typeCode = generateEnumType(enumName, enumDef.enum, enumDef.description)
      typeDefinitions.push(typeCode)
      typeDefinitions.push('')
    } else if (
      enumDef.type === 'array' &&
      enumDef.items?.type === 'string' &&
      Array.isArray(enumDef.items.enum)
    ) {
      // Array of enum strings - generate both the item type and array type
      const itemTypeName = `SURef${capitalize(enumName)}Item`
      const arrayTypeName = `SURef${capitalize(enumName)}`

      // Generate item type
      const itemTypeCode = generateEnumType(
        `${enumName}Item`,
        enumDef.items.enum,
        `Individual ${enumName} value`
      )
      typeDefinitions.push(itemTypeCode)
      typeDefinitions.push('')

      // Generate array type
      const lines: string[] = []
      if (enumDef.description) {
        lines.push('/**')
        lines.push(` * ${enumDef.description}`)
        lines.push(' */')
      }
      lines.push(`export type ${arrayTypeName} = ${itemTypeName}[]`)
      typeDefinitions.push(lines.join('\n'))
      typeDefinitions.push('')
    } else {
      console.warn(`âš ï¸  Skipping ${enumName}: not a string enum or array of enum strings`)
    }
  }

  // Write output file
  const output = typeDefinitions.join('\n')
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8')

  console.log('âœ… Enum types generated successfully!')
  console.log(`ğŸ“„ Output: ${OUTPUT_FILE}`)
  console.log(`ğŸ“Š Generated ${enumNames.length} enum types`)
}

// Run the generator
generateEnumTypes().catch((error) => {
  console.error('âŒ Enum type generation failed:', error)
  process.exit(1)
})
