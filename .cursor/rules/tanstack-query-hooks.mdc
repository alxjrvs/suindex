---
description: TanStack Query hook patterns and conventions
globs:
  - 'apps/suref-web/src/hooks/**/*.ts'
  - 'apps/suref-web/src/hooks/**/*.tsx'
alwaysApply: false
---

TanStack Query hook patterns for data fetching with query key factories, local data support, and mutations.

- Hook structure: Query key factory at the top, `useQuery` hooks for fetching, `useMutation` hooks for updates, support for both API-backed and local (cache-only) data
- Export a query key factory object (e.g., `pilotsKeys`, `mechsKeys`), use hierarchical keys: `['resource', 'subresource', id]`, example: `pilotsKeys.all`, `pilotsKeys.detail(id)`, `pilotsKeys.forCrawler(crawlerId)`
- Hook naming: `use*` for queries (e.g., `usePilot`, `usePilots`), `useHydrated*` for hydrated entities with related data (e.g., `useHydratedPilot`), `useUpdate*`, `useCreate*`, `useDelete*` for mutations, `use*Keys` for query key factories (exported, not hooks)
- Local data support: Use `LOCAL_ID` constant for cache-only data that doesn't persist, check `isLocalId(id)` before making API calls, use `generateLocalId()` for new local entities, use `addToCache()`, `updateInCache()`, `removeFromCache()` helpers
- Always invalidate related query keys on success, use optimistic updates when possible, handle errors appropriately (don't swallow them)
- Query key factory: `export const pilotsKeys = { all: ['pilots'] as const, detail: (id: string) => [...pilotsKeys.all, id] as const, forCrawler: (crawlerId: string) => [...pilotsKeys.all, 'crawler', crawlerId] as const }`
- Query hook: `export function usePilot(id: string | undefined) { return useQuery({ queryKey: pilotsKeys.detail(id!), queryFn: () => fetchEntity<Tables<'pilots'>>('pilots', id!), enabled: !!id && !isLocalId(id) }) }`
- Mutation hook: `export function useUpdatePilot() { const queryClient = useQueryClient(); return useMutation({ mutationFn: ({ id, updates }: { id: string; updates: TablesUpdate<'pilots'> }) => updateEntity('pilots', id, updates), onSuccess: (_, { id }) => { queryClient.invalidateQueries({ queryKey: pilotsKeys.detail(id) }) } }) }`
- Hydrated hooks combine entity data with related data (choices, references): Return a custom interface (e.g., `HydratedPilot`, `HydratedMech`), include the base entity plus hydrated relationships, use `useQuery` to fetch base entity, then hydrate with related data
