---
description: Testing patterns and conventions
globs:
  - "**/*.test.ts"
  - "**/*.test.tsx"
  - "**/__tests__/**/*"
alwaysApply: false
---

# Testing Patterns

## Test Framework

- **Package tests**: Use Bun's built-in test runner
- **App tests**: Use Bun test runner with Testing Library
- Test files: `*.test.ts` or `*.test.tsx`
- Test directories: `__tests__/` or co-located with source

## Testing Library Setup

- Use `@testing-library/react` for component tests
- Use `@testing-library/user-event` for interactions
- Use `@testing-library/jest-dom` for DOM assertions
- Setup files: `testing-library.ts`, `happydom.ts`

## Test Structure

- Use `describe` blocks to group related tests
- Use `test` or `it` for individual test cases
- Follow Arrange-Act-Assert pattern
- Use descriptive test names

## Component Testing

- Test user interactions, not implementation details
- Use `render()` from Testing Library
- Query by accessible roles/labels when possible
- Use `waitFor` for async updates

## Mocking

- Mock Supabase client for API tests
- Use `vi.mock()` for module mocking (Vitest/Bun)
- Mock external dependencies appropriately

## Examples

```ts
// Package test
import { test, expect } from 'bun:test'
import { SalvageUnionReference } from 'salvageunion-reference'

test('model finds item by id', () => {
  const ref = SalvageUnionReference.instance
  const item = ref.chassis.find(x => x.id === 'test-id')
  expect(item).toBeDefined()
})
```

```tsx
// Component test with path aliases
import { render, screen } from '@testing-library/react'
import { test, expect } from 'bun:test'
import { PilotComponent } from '@/components/PilotLiveSheet'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

test('renders pilot name', () => {
  const queryClient = new QueryClient()
  render(
    <QueryClientProvider client={queryClient}>
      <PilotComponent id="test-id" />
    </QueryClientProvider>
  )
  expect(screen.getByText('Pilot Name')).toBeInTheDocument()
})
```
